## 1. Введение (контекст, цели)

Рекап – это краткое напоминание о событиях предыдущих эпизодов сериала, включающее основные сюжетные повороты и персонажей. Задача проекта – автоматизировать создание таких рекапов в текстовом и видеоформате на русском языке. Система должна обрабатывать входные видеофайлы эпизодов и соответствующие им субтитры и выдавать:
- текстовый рекап в файле `.txt` (100–500 слов);
- видеорекап длительностью 2–3 минуты в формате `.mp4`.

Цель проекта – дать пользователю возможность быстро освежить события сериала при перерыве в просмотре, без повторного просмотра всех серий. Решение выполняется в условиях хакатона: полностью локально (без доступа в интернет) на выделенной машине с одной GPU (NVIDIA A100 80 GB VRAM). Будут использоваться только опенсорсные модели и локальные ресурсы (все веса моделей должны быть включены в Docker-образ).

[ПРЕДПОЛОЖЕНИЕ: входные видео и субтитры всегда идут парами и имеют корректные имена формата `compilationId_seasonId_episodeId`. Все файлы хранятся в локальных папках `videos/` и `subtitles/`, поэтому операции ввода-вывода происходят в пределах контейнера.]

## 2. Функциональные требования

- **Вход и выход:** Система принимает на вход один или несколько видеофайлов эпизодов (формат MP4/AVI) и соответствующие файлы субтитров (`.srt`) с именами `compilationId_seasonId_episodeId`. На выходе она должна генерировать для каждого эпизода:
    - текстовый файл `.txt` с текстовым рекапом;
    - видеофайл `.mp4` (2–3 минуты), собранный из ключевых сцен эпизода;
    - _(опционально)_ JSON-файл с метаданными: идентификатор серии и таймкодами ключевых событий (отчет из логов).

- **Режимы работы (CLI):** Предусмотреть интерфейс командной строки с параметрами запуска. Например:
```bash
`recap-cli \
	--config config.yaml \
	--mode single|batch|season \
	--input ./videos/... \
	--subtitle ./subtitles/... \
	--output ./results \
	--genre <жанр> \
	--adult  \
	--dry-run`
```
	 - где `--mode` выбирает сценарий обработки (`single` – одна серия, `batch` – все серии из директории, `season` – все эпизоды сезона); `--dry-run` – режим проверки без финального монтажа видео. Команда должна принимать путь к входным данным, директорию вывода и дополнительные опции (`--genre`, `--adult` и т.д.). В ходе работы CLI выводит понятные статусы и прогресс каждой стадии.

- **Обработка и анализ контента:**

    - Система выделяет ключевые сюжетные события и персонажей на основе анализа субтитров и видеоряда. Например, с помощью видеоанализа (кадры) и NLP-анализа текстов.

    - Текстовый рекап должен быть логически структурирован (хронология, разделение на сюжетные блоки) и стилистически соответствовать жанру сериала (тоновость, возможное использование характерных цитат).

    - Видеорекап формируется из нарезки ключевых фрагментов исходного видео и сопровождается закадровым текстом/титрами. _[ПРЕДПОЛОЖЕНИЕ: поскольку синтез речи (TTS) не требуется, можно обойтись простыми текстовыми титрами или субтитрами в финальном видео вместо голосового озвучивания]._

- **Поддержка форматов:** Поддерживаются входные форматы `.mp4` и `.avi`, субтитры – `.srt`. На выходе создаётся видео в формате `.mp4`. Кодеки – стандартные, используемые в исходных файлах (предположительно H.264/MP4).

- **Масштабирование и производительность:** Проект рассчитан на ограниченный объём данных (до 3 сериалов, примерно 40 эпизодов). Параллельная обработка эпизодов не требуется (одна задача в процессе). Целевое время генерации: порядка 5 минут на один эпизод (MVP). [ПРЕДПОЛОЖЕНИЕ: в расчётах на время использования A100 GPU (80 GB) и квантованных моделей для продакшена].

- **Дополнительные выходы и качество:** По желанию в систему может быть добавлено сохранение логов процесса (JSON, файл `logs.json`), а также сбор элементарных метрик (время на этап, потребление памяти) для отладки. Результаты каждого запуска должны сохраняться в отдельной директории (с пометкой версии или отметкой времени), чтобы не затирать предыдущие данные.


## 3. Нефункциональные требования

- **Платформа:** Python ≥ 3.10 с полными типовыми аннотациями и докстрингами. Код форматирован по стандартам (PEP8), снабжён юнит-тестами. Проект упакован в Docker-контейнер (образ не более ~20 GB), запускаемый локально без интернета.

- **Производительность:** Оптимизированное использование ресурсов: предполагается одна GPU (NVIDIA A100 80 GB) и достаточно CPU. Максимальная длина обрабатываемого контента – до ~3 минут видео (~500 слов текста) для одного эпизода и до ~10 минут (~2000 слов) для всех эпизодов сезона. Использование квантованных (INT8/INT4) моделей для продакшена обязательно для укладки в память. Фоновое дообучение или обновление моделей не проводится (работа – только inference).

- **Ресурсы:** Все модели и библиотеки должны работать офлайн. Мы предполагаем хранить веса моделей локально в контейнере или автоматически загружать при сборке образа. Не должно быть привязки к внешним API (за исключением, возможно, локального сервиса инференса, такого как Ollama).

- **Качество и логирование:** Логирование – структурированный JSON-лог (INFO/DEBUG/ERROR уровни). При возникновении ошибки (например, сбой загрузки модели или недоступность сервиса инференса) производится повтор попытки (до 3 раз), далее система завершает работу с ошибкой и записью проблемы в лог. Падение контейнера или критические сбои также фиксируются и останавливают процесс.

- **Конфигурация:** Параметры запуска (пути, режим, выбор модели, опции) задаются через YAML-файлы (например, `config.yaml`) и CLI. Поддерживаются разные конфигурации: выбор модели LLM, режим (single/batch/season), параметры сегментации, dry-run и др. Dry-run должен прогонять пайплайн без инференса, проверяя корректность шагов.

- **Ограничения данных:** Субтитры должны быть в стандартизированном формате SRT. Случаи полностью отсутствующих или битых субтитров в рамках текущего проекта не обрабатываются (будем считать, что субтитры всегда корректны).

## 4. Архитектура решения

Архитектура модульная, включает четыре основных компонента, соединённых в конвейер:

- **4.1 Preprocessor (ингест и подготовка):** Загружает входные файлы (видео и субтитры), проверяет их формат и целостность. Нормализует таймкоды субтитров, извлекает аудио/видео-потоки (возможно). Делит видео на сцены (например, с помощью PySceneDetect) и извлекает ключевые кадры. Подготавливает данные для дальнейших модулей: кадры и соответствующие тексты субтитров в унифицированном формате. Результаты сохраняются во временных структурах и могут кешироваться.

- **4.2 Extraction Engine (выделение ключевых событий):** Анализирует подготовленные данные для определения ключевых событий. Например, для каждого кадра или короткого сегмента генерирует текстовое описание с помощью мультимодальной модели (ruCLIP с ViT+ruGPT3 или аналог). Затем оценивает важность этих фрагментов с помощью LLM (метод sliding window scoring) и глобальной агрегации. На выходе даёт список {`start`, `end`} отрезков (или меток событий) с их оценками важности. Количество ключевых событий определяется динамически, без фиксированных минимальных/максимальных порогов.

- **4.3 LLM-модуль (генерация текста):** Принимает на вход описания ключевых кадров и их важности и формирует на их основе связный структурированный текст рекапа (Markdown или Plain Text). Используются открытые русскоязычные модели LLM: например, LLaMA-3 (saiga) 8B/12B и специализированный summarizer (FRED-T5). В дев-режиме применяются легковесные квантованные модели (GGUF/INT4) для экономии памяти, в продакшене – их неквантованные «тяжёлые» версии. Модуль оптимизируется через продуманное промпт-инжиниринг, батчинг запросов и использование квантованных моделей, чтобы укладываться в A100. Интерфейс – единый Python-вызов (никаких REST): функция возвращает финальный текст рекапа.

- **4.4 Video Compiler (монтаж видеорекапа):** Получает список ключевых таймкодов от Extraction Engine и собирает из них видеоролик. С помощью MoviePy или ffmpeg внутри Docker вырезаются и склеиваются отрезки исходного видео. Видео может сопровождаться текстовыми титрами/субтитрами с рекапом. В финале модуль экспортирует итоговый файл `episode_recap.mp4`.


Компоненты связаны последовательно (Preprocessor → Extraction Engine → LLM-модуль → Video Compiler). Каждый этап может сохранять промежуточные результаты (такие как данные о сценах или важности) в дисковом кеше (`cache/`), ускоряя повторные прогоны.

## 5. Конфигурация и управление

- **Файлы конфигурации (YAML/Hydra):** Для гибкости настроек используется Hydra-Core или OmegaConf. Файл `config.yaml` описывает выбор моделей (dev/prod), параметры сегментации, пути к ресурсам, режим работы (`single`/`batch`/`season`), параметры LLM (температура, max токенов) и т.д. Изменяя конфиг, можно перенастраивать систему без правки кода.

- **CLI-интерфейс:** Пример команды приведён выше. CLI оперирует ключевыми флагами (`--config`, `--mode`, `--input`, `--output`, `--genre`, `--adult`, `--dry-run` и др.). Скрипт выводит пошаговый прогресс и служебную информацию. Если указан `--dry-run`, он проходит все этапы, но не выполняет фактический инференс и монтаж.

- **Управление версиями вывода:** По каждому запуску в папке `--output` создаётся новая подпапка с меткой версии (например, временной меткой). В неё сохраняются все результаты: текстовый рекап, видеорекап, JSON и логи. Это позволяет хранить историю генераций и не затирать прошлые данные.

## 6. Работа с ошибками и кешированием

- **Обработка ошибок:** На уровне каждого модуля ошибки перехватываются. При сбое (например, неудачная загрузка модели или отсутствие файла) выводится ERROR в лог, выполняются до 3 повторных попыток. Если после трёх попыток проблема не решена, система завершает работу с сообщением об ошибке. Критические сбои (падение контейнера, недоступность модели инференса) также останавливают процесс с соответствующим уведомлением.

- **Логирование:** Все ключевые шаги процесса фиксируются. Логи пишутся в JSON-формате (уровни INFO/DEBUG/ERROR). В логах можно дополнительно отмечать время выполнения этапов и потребление памяти. Это помогает отладке и профилированию.

- **Кеширование:** Для ускорения повторных прогонов (одних и тех же файлов с целью получить несколько версий рекапов и выбрать лучший) сохраняются промежуточные результаты тяжёлых операций (детекция сцен, извлечение описаний, оценка важности) в директории `cache/`. При повторном запуске с теми же входными данными модули могут загрузить данные из кэша вместо повторных вычислений. Это экономит время при отладке и тестировании.

## 7. Стек технологий (предполагаемый)

- **Язык и среда:** Python 3.10+, Docker (Linux-контейнер). GPU-ускорение через CUDA (PyTorch).

- **ML/LLM:** PyTorch, Hugging Face Transformers (+ datasets/PEFT). Модели: ru-CLIP, LLaMA-3 (saiga) 8B/12B, FRED-T5-Summarizer 1.7B (RussianNLP), их квантованные версии (GGUF). Возможна интеграция с локальным сервером инференса LLM (например, Ollama или аналог).

- **Видео и аудио:** MoviePy или FFmpeg для нарезки и склейки видео; PySceneDetect для детекции сцен. (Дополнительно: OpenCV или другие утилиты для работы с изображениями, если понадобится).

- **Конфигурация и утилиты:** Hydra-Core (OmegaConf) для YAML, логгер `loguru` (JSON-вывод), Click/Argparse для CLI.

- **Разработка:** Git (репозиторий с кодом), pytest для тестов.

- **Окружение:** Доступна одна GPU (NVIDIA A100 80 GB). В режиме разработки можно использовать более лёгкие GPU/CPU и квантованные модели. [ПРЕДПОЛОЖЕНИЕ: для инференса используется PyTorch с оптимизациями под GPU].


## 8. Критерии приемки решения на хакатоне

- **Качество рекапов:** Текстовый рекап должен быть связным, покрывать все значимые сюжетные линии и персонажей без потери хронологии. Объём – в заданном диапазоне (100–500 слов). Видеорекап (~2–3 минуты) – логично смонтирован, отражает ключевые события эпизода. За точность и полноту будет отвечать экспертная оценка редакторов по критериям: «логичная структура», «полнота» и «жанровая стилистика».

- **Техническая реализация:** Чистый, хорошо структурированный код; модульная архитектура; наличие юнит-тестов и примеров использования. Полная документация: инструкции по сборке Docker-образа, запуску и использованию (README, примеры CLI).

- **Удобство использования:** Простота запуска через одну команду, понятные сообщения об ошибках, минимальные ручные действия (всё настраивается через конфиг и CLI).

- **Креативность:** Дополнительные функции или особенности (например, стилистические эффекты в тексте, подбор фоновой музыки, дополнительные отчёты) приветствуются, но служат лишь бонусом. Основные функции выполняются в любом случае.
